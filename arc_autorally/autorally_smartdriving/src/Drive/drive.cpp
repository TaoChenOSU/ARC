/**********************************************
* @file drive.cpp
* @author Tao Chen <chentao@oregonstate.edu>
* @date March 07, 2017
* @copyright 2017 Oregon State University
* @brief ROS node to drive the car following the path generated by move_base
*
* @details This node subscribes to /cmd_vel topic from local_base_plan (move_base)
*           then convert the /cmd_vel to chassis commands.
***********************************************/
#include "drive.h"

namespace autorally_smartdriving{
  Drive::Drive(){
    d_driveSub = d_nh.subscribe("/cmd_vel", 50, &Drive::gatherVelData, this);
    d_drivePub = d_nh.advertise<autorally_msgs::chassisCommand>("/drive/chassisCommand", 10);
    //d_constSpeedPub = d_nh.advertise<std_msgs::Float64>("constantSpeedController/speedCommand", 1);
    d_odomSub = d_nh.subscribe("/odom", 1, &Drive::gatherOdomData, this);
    d_goalSub = d_nh.subscribe("/move_base/current_goal", 1, &Drive::getCurrentGoal, this);
    ROS_INFO("smartdriving_drive initialization completed");

    goalX = 1.0/0.0;         //initialy infinity
    goalY = 1.0/0.0;

    reached = false;
  }

  Drive::~Drive(){}

  void Drive::gatherOdomData(nav_msgs::Odometry data){
    double x = data.pose.pose.position.x;
    double y = data.pose.pose.position.y;

    double diffX = 0;
    double diffY = 0;

    //only if the goal is set
    if(!isinf(goalX) && !isinf(goalY)){
      //stop if within 5 units
      diffX = abs(goalX - x);
      diffY = abs(goalY - y);
      //ROS_INFO("diffX = %f, diffY = %f", diffX, diffY);
      if(diffX < 1 && diffY < 1){
        reached = true;
      }
    }else{
      reached = false;
    }

  }

  void Drive::getCurrentGoal(geometry_msgs::PoseStamped data) {
    goalX = data.pose.position.x;
    goalY = data.pose.position.y;

    reached = false;
  }

  void Drive::gatherVelData(geometry_msgs::Twist data){
    autorally_msgs::chassisCommand command;
    //std_msgs::Float64 speed;

    if(!reached){
      command.throttle = data.linear.x;
      command.frontBrake = 0;
      command.steering = -data.angular.z;
    }else{
      command.throttle = 0;    // full electronic brake
      command.frontBrake = 1;   // full front brake
      command.steering = 0.0;
    }

    command.header.stamp = ros::Time::now();
    command.sender = "drive";

    ROS_INFO("New turning angle: %f. Reached: %d", command.steering, reached);
    d_drivePub.publish(command);
  }

  double Drive::AngleDiff(double a, double b){
    double dif = fmod(a-b + PI, 2.0*PI);
    if (dif < 0)
      dif += 2.0*PI;
    return dif - PI;
  }

  double Drive::Clamp(double num, double min, double max){
    if (num < min)
      num = min;
    if (num > max)
      num = max;
    return num;
  }
};

int main(int argc, char** argv){
	ros::init(argc, argv, "drive");
	autorally_smartdriving::Drive drive;
	ros::spin();
}
